"""
Принцип открытости/закрытости (Open/Closed Principle, OCP) — это второй принцип SOLID, который гласит, 
что программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для 
изменения. Это значит, что вы должны проектировать классы так, чтобы можно было добавлять новые 
возможности без изменения уже существующего кода. Таким образом, новая функциональность добавляется за 
счёт расширения, а не изменения, что помогает избежать непреднамеренных ошибок в старом коде.

В чем суть принципа OCP?
Идея принципа в том, чтобы минимизировать изменения в существующем коде, особенно если он уже прошел 
тестирование и используется другими частями программы. Если классы можно расширять (например, через 
наследование или полиморфизм), то новые возможности можно добавлять без риска повредить основную 
функциональность, уже реализованную в базовом коде.
"""

# При добавлении нового user_type прийдеться изменять метод calculate что нарушает принцып OCP
class DiscountCalculator:
    def calculate(self, user_type, price):
        if user_type == 'regular':
            return price * 0.95  # Скидка 5%
        elif user_type == 'vip':
            return price * 0.8   # Скидка 20%

# Пример как нужно реализовывать
from abc import ABC, abstractmethod

# Аюстрактный класс для скидок (Интерфейс)
class Discount(ABC):
    @abstractmethod
    def apply(self, price):
        pass 

# 1 Первый тип скидки в 5%
class RegularDiscount(Discount):
    def apply(self, price):
        return price * 0.95 # Скидка 5%

# 2 Второй тип скидки в 20%   
class VipDiscount(Discount):
    def apply(self, price):
        return price * 0.8 # Скидка 20%

# 3 Третий тип скидки в 10%     
class PremiumDiscount(Discount):
    def apply(self, price):
        return price * 0.9 # Скидка 10%
    
# Если нужно добавить новый тип скидки, достаточно создать новый клас
# и унаследовать Интерфейс и определить метод apply

class DiscountCalculator:
    def __init__(self, disc: Discount):
        # Сохраняем екземпляр класса где храниться логика скидки
        # Можно передать RegularDiscount, VipDiscount, PremiumDiscount
        self.disc = disc

    def calculate(self, price):
        """Вернут размер скидки"""
        return self.disc.apply(price)
    
"""
Для реализации принцыпа OCP использовал Полиморфизм и Интерфейс, интерфейс позволяет прописать правила заполнения класса скидка
определить общюю структуру для всех скидок, Полиморфизм позволяет получать скидку от любого типа скидок, так как у всех классов
есть метод apply

Теперь когда будет новая скидка, нужно будет рассышрить код, создать новый класс, унаследовать интерфейс Discount определить метод
apply и дальшее в класс DiscountCalculator можно передавать обьект 
"""

# Создания типа скидок
r = RegularDiscount()
v = VipDiscount()
p = PremiumDiscount()

# Создания калькулятора для каждого типа скидок
cal1 = DiscountCalculator(r)
cal2 = DiscountCalculator(v)
cal3 = DiscountCalculator(p)

# Расчет и получения каждой цены с учетом скидки
print(cal1.calculate(100)) # 95
print(cal2.calculate(100)) # 80
print(cal3.calculate(100)) # 90
