"""
@cached_property - это декторатор для кешыровния, устроин следующим образом, когда мы обращаемся к атрибуту
происходит вычисления атрибута и результат записываеться в атрибут, и при повтором обращении к атрибуту 
вычислени не будет происходить а будет возрвщаться результат. Это что то похоже на логику слудующюю
Есди переменная пустая, вычеслить еее и записать значения и при воторном обращении переменная будет не пустая
и вычисления уже не будет происходить
"""

from functools import cached_property

class MapKlada:
    def __init__(self, kef, title):
        self.kef = kef
        self.title = title

    @cached_property
    def calkulete_poz(self):
        """Вычесления  будет сделано 1 раз при первом обращении к obj.calkulete_poz"""
        return [5 * self.kef, 6 * self.kef, 1 * self.kef]
    
main_map = MapKlada(2, 'Карта сокровищ')
print(main_map.calkulete_poz) # [10, 12, 2] Расчет значений
print(main_map.calkulete_poz) # [10, 12, 2] Закешырованый результат

main_map.kef = 4
print(main_map.calkulete_poz) # [10, 12, 2] Значения не меняеться при изменении коофицыента, так как результат закешырован

# Как удалить Кеш и расчитать значения заново и закешыровать его
del main_map.__dict__['calkulete_poz'] # Момент удаления

# Делаем новый расчет и кешыруем его, ВАЖНО у нас новый коофицыент 4
print(main_map.calkulete_poz) # [20, 24, 4] Расчет значений
print(main_map.calkulete_poz) # [20, 24, 4] Закешырованый результат

"""
Особенности декторатор

1. Не поддержывает установку или удаления значения на прямую
2. Работает только с обьектами класса, а не с саммим классом
3. Только для чтения, установить значения нельзя
4. Ограничения совместимости: Работает только в Python 3.8 и выше.
"""
